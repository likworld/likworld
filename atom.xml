<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lk&#39;logs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.lklogs.com/"/>
  <updated>2020-06-08T13:24:48.311Z</updated>
  <id>http://www.lklogs.com/</id>
  
  <author>
    <name>江湖小郎中</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>elasticsearch-jdbc连接（version6.3+）</title>
    <link href="http://www.lklogs.com//blog/elasticsearch-jdbc%E8%BF%9E%E6%8E%A5%EF%BC%88version6.3+%EF%BC%89.html"/>
    <id>http://www.lklogs.com//blog/elasticsearch-jdbc连接（version6.3+）.html</id>
    <published>2020-06-05T05:16:52.000Z</published>
    <updated>2020-06-08T13:24:48.311Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>因近期业务需要，需要编写不同数据库插件来访问不同数据库的详细信息，当前是elasticsearch简单的jdbc如何连接<br><a id="more"></a></p><h1 id="ElasticSearch-jdbc"><a href="#ElasticSearch-jdbc" class="headerlink" title="ElasticSearch-jdbc"></a>ElasticSearch-jdbc</h1><h2 id="第一步，找到es-jdbc的jar"><a href="#第一步，找到es-jdbc的jar" class="headerlink" title="第一步，找到es-jdbc的jar"></a>第一步，找到es-jdbc的jar</h2><ol><li><p>查看自己本地elasticsearch的版本</p><p>在官网中找到符合自己版本的jdbc client.jar<font color="red"> 如果版本出错的话，会有明确的错误信息指出的</font></p><p>官网地址:<a href="https://www.elastic.co/cn/downloads/past-releases#jdbc-client" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/past-releases#jdbc-client</a></p></li><li><p>下载jar包</p></li></ol><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/jdbc/elasticsearch/es-jdbc.png" alt></p><font color="red">项目中添加依赖</font><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.elasticesearch-plugin<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>x-pack-sql-jdbc<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">version</span>></span>6.7.0<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">repositories</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">repository</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">id</span>></span>elastic.co<span class="tag"></<span class="name">id</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">url</span>></span>https://artifacts.elastic.co/maven<span class="tag"></<span class="name">url</span>></span></span><br><span class="line">  <span class="tag"></<span class="name">repository</span>></span></span><br><span class="line"><span class="tag"></<span class="name">repositories</span>></span></span><br></pre></td></tr></tbody></table></figure><p>但是maven仓库中是不存在这个jar的，还是需要自己手动下载</p><h2 id="第二步，加载es驱动"><a href="#第二步，加载es驱动" class="headerlink" title="第二步，加载es驱动"></a>第二步，加载es驱动</h2><p>esDriver引入：<font color="red">org.elasticsearch.xpack.sql.jdbc.EsDriver</font></p><p>url语法：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:es://[http|https]?[host[:port]]*/[prefix]*[?[option=value]&]*</span><br></pre></td></tr></tbody></table></figure><p>这里就不赘述相关的连接配置了，如果有需要[传送门][<a href="https://github.com/jprante/elasticsearch-jdbc]" target="_blank" rel="noopener">https://github.com/jprante/elasticsearch-jdbc]</a></p><h2 id="第三步，启动elasticsearch"><a href="#第三步，启动elasticsearch" class="headerlink" title="第三步，启动elasticsearch"></a>第三步，启动elasticsearch</h2><p>找到es的目录，点击<font color="red">elasticsearch.bat</font>启动，访问<a href="http://127.0.0.1:9200" target="_blank" rel="noopener">http://127.0.0.1:9200</a></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/jdbc/elasticsearch/es-start.png" alt></p><h2 id="第四步，编写代码进行测试"><a href="#第四步，编写代码进行测试" class="headerlink" title="第四步，编写代码进行测试"></a>第四步，编写代码进行测试</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lklogs.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ESJdbcFirst</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Class.forName(<span class="string">"org.elasticsearch.xpack.sql.jdbc.EsDriver"</span>);</span><br><span class="line">            FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"F:/workspace/_ElasticSearch_jdbc/src/main/resources/es.properties"</span>);</span><br><span class="line">            Properties pps = <span class="keyword">new</span> Properties();</span><br><span class="line">            pps.load(fileInputStream);</span><br><span class="line">            Connection connection = DriverManager.getConnection(</span><br><span class="line">                    pps.getProperty(<span class="string">"url"</span>),</span><br><span class="line">                    pps.getProperty(<span class="string">"username"</span>),</span><br><span class="line">                    pps.getProperty(<span class="string">"password"</span>));</span><br><span class="line">            System.out.println(connection);</span><br><span class="line">        } <span class="keyword">catch</span> (ClassNotFoundException | FileNotFoundException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">catch</span> (SQLException throwables) {</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>项目上传到GitHub中，如需要查看项目代码，[请点击][<a href="http://https://github.com/likworld/jdbc_database]" target="_blank" rel="noopener">http://https://github.com/likworld/jdbc_database]</a></p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因近期业务需要，需要编写不同数据库插件来访问不同数据库的详细信息，当前是elasticsearch简单的jdbc如何连接&lt;br&gt;
    
    </summary>
    
      <category term="jdbc" scheme="http://www.lklogs.com/categories/jdbc/"/>
    
    
      <category term="jdbc" scheme="http://www.lklogs.com/tags/jdbc/"/>
    
  </entry>
  
  <entry>
    <title>CAS原子操作实现原理</title>
    <link href="http://www.lklogs.com//blog/CAS%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html"/>
    <id>http://www.lklogs.com//blog/CAS原子操作实现原理.html</id>
    <published>2020-05-20T13:12:57.000Z</published>
    <updated>2020-05-20T13:17:58.181Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>总结CAS存在的问题和相对应的CPU术语以及汇编层面的实现<br><a id="more"></a><br>CPU术语定义</p><table><thead><tr><th style="text-align:center">术语名称</th><th style="text-align:center">英文</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">缓存行</td><td style="text-align:center">Cache line</td><td style="text-align:center">缓存的最小操作单位</td></tr><tr><td style="text-align:center">比较并交换</td><td style="text-align:center">Compare and Swap</td><td style="text-align:center">CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较旧值有没有变化，如果没有发生变化，才交换新值，发生了变化则不交换</td></tr><tr><td style="text-align:center">CPU流水线</td><td style="text-align:center">CPU pipeline</td><td style="text-align:center">CPU流水线的工作方式就像工业生产上的装配流水线，在CPU中由5-6个不同功能的电路单元组成一条指令处理流水线，然后将一条X86指令分成5-6步后再由这些电路单元分别执行，这样就能实现在一个CPU时钟周期完成一条指令，因此提高CPU的运算速度</td></tr><tr><td style="text-align:center">内存顺序冲突</td><td style="text-align:center">Memory order violation</td><td style="text-align:center">内存顺序冲突一般是由假共享引起的，假共享是指多个CPU同时修改一个缓存行的不同部分而引起其中一个CPU的操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线</td></tr></tbody></table><p><strong>CAS有四个操作数，分别为：对象内存位置、对象中的变量的偏移量、变量预期值和新的值。</strong></p><p><strong>处理器如何实现原子操作</strong>：32位IA-32处理器使用基于<font color="red">对缓存加锁或总线加锁的方式</font>来实现多处理器之间的原子操作。</p><p><strong>CAS存在的问题</strong></p><ol><li>ABA问题</li><li>循环时间长开销大</li><li>只能保证一个共享变量的原子操作</li></ol><p><strong>ABA问题</strong></p><p>​    解决思路：在变量前面追加版本号每次变量更新的时候把版本号加1，那么A->B->C变成1A->2B-3A。java1.5开始Atomic包提供了一个类AtomicStampedReference来解决ABA问题，这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><p><strong>循环时间长开销大</strong></p><p>​    自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。</p><p>pause指令有两个作用：</p><ol><li>它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零</li><li>它可以避免在退出循环的时候因内存顺序冲突（Memory order violation）而引起CPU流水线被清空（CPU pipeline flush）,从而提高CPU的执行效率</li></ol><p><strong>只能保证一个共享变量的原子操作</strong></p><p>​    循环CAS的方式只能保证一个共享变量的原子性，对于多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p><p><strong>使用锁机制实现原子操作</strong></p><p>​    锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</p><p>java中的CAS操作利用处理器提供的CMPXCHG（比较并交换）指令实现的。</p><font color="red">最终实现：</font><font color="red">如果是一个CPU使用cmpxchg 这条指令不能保证原子性，多个CPU需要加Lock;</font><br><font color="red">硬件：lock指令在执行后面指令的时候锁定一个北桥信号（不采用锁总线的方式）</font></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结CAS存在的问题和相对应的CPU术语以及汇编层面的实现&lt;br&gt;
    
    </summary>
    
      <category term="Thread笔记" scheme="http://www.lklogs.com/categories/Thread%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Thread" scheme="http://www.lklogs.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>volatile基础介绍</title>
    <link href="http://www.lklogs.com//blog/volatile%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D.html"/>
    <id>http://www.lklogs.com//blog/volatile基础介绍.html</id>
    <published>2020-05-20T12:58:55.000Z</published>
    <updated>2020-05-20T13:01:13.182Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>主要介绍volatile的具体实现（不同层面），以及底层的实现原理和相对应的CPU术语<br><a id="more"></a><br><strong>字节码层面</strong>：ACC_VOLATITLE</p><p><strong>JVM规范要求实现</strong></p><hr><p>StoreStoreBarrier  |         LoadLoadBarrier</p><p><em>volatile写操作</em>          |         <em>volatile读操作</em></p><p>StoreLoadBarrier   |         LoadStoreBarrier</p><hr><p><strong>HotSpot的实现 ：</strong> lock addl </p><p><strong>volatile具体作用：</strong></p><ol><li>保证共享变量的可见性</li><li>不保证共享变量的原子性</li><li>避免指令重排(内存屏障:禁止指令顺序颠倒)</li></ol><p><strong>volatile的应用：</strong>  </p><p>​    volatile是轻量级的synchronized，它在多线程处理器开发中保证了共享变量的可见性。  </p><p>​    可见性：当一个线程修改一个共享变量时，其他线程能读到这个修改的值。</p><p>​    volatile与synchronized相比优势  如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</p><p><strong>volatile的定义与实现原理</strong>  </p><p>​    java语言规范第三版对volatile的定义如下：java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。java语言提供了volatile，在某些情况下比锁要更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p><p><strong>实现原理相关的CPU术语</strong></p><table><thead><tr><th style="text-align:center">术语</th><th style="text-align:center">英文单词</th><th style="text-align:center">术语描述</th></tr></thead><tbody><tr><td style="text-align:center">内存屏障</td><td style="text-align:center">memory barriers</td><td style="text-align:center">是一组处理器指令，用于实现对内存操作的顺序限制</td></tr><tr><td style="text-align:center">缓存行</td><td style="text-align:center">cache line</td><td style="text-align:center">缓存中可以分配的最小存储单位。处理器填写缓存线时会加载整个缓存线，需要使用多个主内存读周期</td></tr><tr><td style="text-align:center">原子操作</td><td style="text-align:center">atomic operations</td><td style="text-align:center">不可中断的一个或一系列操作</td></tr><tr><td style="text-align:center">缓存行填充</td><td style="text-align:center">cache line fill</td><td style="text-align:center">当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当的缓存(L1、L2、L3的或所有)</td></tr><tr><td style="text-align:center">缓存命中</td><td style="text-align:center">cache hit</td><td style="text-align:center">如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存行中读取操作数，而不是从内存读取</td></tr><tr><td style="text-align:center">写命中</td><td style="text-align:center">write hit</td><td style="text-align:center">当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存中，而不是写回到内存，这个操作被称为写命中</td></tr><tr><td style="text-align:center">写缺失</td><td style="text-align:center">write misses the cache</td><td style="text-align:center">一个有效的缓存行被写入到不存在的内存区域</td></tr></tbody></table><p><strong>volatile是如何来保证可见性的？</strong></p><p>​    java代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance = <span class="keyword">new</span> Singleton(); <span class="comment">// instance是volatile变量</span></span><br></pre></td></tr></tbody></table></figure><p>转变成汇编代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x01a3de1d</span>: movb $<span class="number">0x0</span>,<span class="number">0x1104800</span>;<span class="number">0x01a3de24</span>: lock add1 $<span class="number">0x0</span>,(%esp)</span><br></pre></td></tr></tbody></table></figure><p><strong>lock前缀的指令在多核处理器下会引发</strong></p><ol><li>将当前处理器缓存行的数据写回到系统内存</li><li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效</li></ol><p>为了提高处理器速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(L1，L2或其他)后再进行操作，但操作完不知道何时会写回到内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以在多处理器下，为了保证各个处理器缓存是一致的，就会实现<strong>缓存一致性协议</strong>，每个处理器通过<strong>嗅探在总线上传播的数据</strong>来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p><p><strong>Lock前缀指令会引起处理器缓存写到内存</strong></p><p>​    Lock前缀指令导致在执行期间，声言处理器的LOCK#信号。在多线程环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。但是，在最近的处理器里，LOCK#信号一般不锁总线，而是锁缓存，毕竟锁总线开销的比较大。锁定操作对多线程缓存的影响？对于Intel486和Pentium处理器，在锁操作时，总是在总线上声言LOCK#信号。但在P6和目前的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。一个处理器的缓存回写到内存会导致其他处理器的缓存无效。  IA-32处理器和Intel64处理器使用<strong>MESI(修改、独占、共享、无效)控制协议</strong>去维护内部缓存和其他处理器缓存的一致性。在多核处理器系统中进行操作的时候，IA-32和Intel 64处理器能嗅探其他处理器访问系统内存和它们的内部缓存。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。例如，在Pentium和P6 family处理器中，如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。</p><p><strong>volatile的优化</strong></p><p>​    字节填充(追加到64字节的方式来填满高速缓存区的缓存行)</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍volatile的具体实现（不同层面），以及底层的实现原理和相对应的CPU术语&lt;br&gt;
    
    </summary>
    
      <category term="Thread笔记" scheme="http://www.lklogs.com/categories/Thread%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Thread" scheme="http://www.lklogs.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>GC Roots</title>
    <link href="http://www.lklogs.com//blog/GCRoots.html"/>
    <id>http://www.lklogs.com//blog/GCRoots.html</id>
    <published>2020-05-20T11:36:10.000Z</published>
    <updated>2020-05-20T11:38:48.627Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>GC Roots都包含哪些？<br><a id="more"></a><br>在java技术体系里面，固定可作为GC Roots的对象包括以下几种：</p><ul><li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等</li><li>在方法区中类静态属性引用的对象，譬如java类的引用类型静态变量</li><li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用</li><li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象</li><li>java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器</li><li>所有被同步锁（synchronized关键字）持有的对象</li><li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等  </li></ul><p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”的加入，共同构成完整GC Roots集合。譬如后文将会提到的分代收集和局部回收（Partial GC），如果只针对java堆中的某一块区域发起垃圾收集时（如最典型的只针对新生代的垃圾收集），必须考虑到内存区域是虚拟机自己的实现细节（在用户视角里任何内存区域都是不可见的），更不是孤立封闭的，所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引用，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确性。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GC Roots都包含哪些？&lt;br&gt;
    
    </summary>
    
      <category term="GC笔记" scheme="http://www.lklogs.com/categories/GC%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="GC" scheme="http://www.lklogs.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>G1问题</title>
    <link href="http://www.lklogs.com//blog/G1%E9%97%AE%E9%A2%98.html"/>
    <id>http://www.lklogs.com//blog/G1问题.html</id>
    <published>2020-05-20T04:20:10.000Z</published>
    <updated>2020-05-20T04:25:17.593Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>本文简单阐述G1中的跨代指针、用户线程和收集线程的隔离性、以及可停顿模型的建立基础</p><a id="more"></a><p><strong>将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决？</strong></p><p>使用记忆集避免全堆作为GC Roots扫描，但在G1收集器上记忆集的应用其实要复杂很多，它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。G1的记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。这种“双向”的卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担。根据经验，G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作。</p><p><strong>在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？</strong></p><p>这里首先要解决的是用户线程改变对象引用关系时，必须保证其不能打破原本的对象图结构，导致标记结果出现错误，该问题的解决办法笔者已经抽出独立小节来讲解过（见3.4.6节）：CMS收集器采用增量更新算法实现，而G1收集器则是通过原始快照（SATB）算法来实现的。此外，垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上，程序要继续运行就肯定会持续有新对象被创建，G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。与CMS中的“Concurrent Mode Failure”失败会导致Full GC类似，如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致FullGC而产生长时间“Stop The World”。  </p><p><strong>怎样建立起可靠的停顿预测模型？</strong></p><p>用户通过-XX：MaxGCPauseMillis参数指定的停顿时间只意味着垃圾收集发生之前的期望值，</p><p><strong>但G1收集器要怎么做才能满足用户的期望呢？</strong></p><p>G1收集器的停顿预测模型是以<strong>衰减均值（Decaying Average）</strong>为理论基础来实现的，在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息。这里强调的“衰减平均值”是指它会比普通的平均值更容易受到新数据的影响，平均值代表整体平均状态，但衰减平均值更准确地代表“最近的”平均状态。换句话说，Region的统计状态越新越能决定其回收的价值。然后通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单阐述G1中的跨代指针、用户线程和收集线程的隔离性、以及可停顿模型的建立基础&lt;/p&gt;
    
    </summary>
    
      <category term="GC笔记" scheme="http://www.lklogs.com/categories/GC%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="GC" scheme="http://www.lklogs.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>GC参数总结</title>
    <link href="http://www.lklogs.com//blog/%E5%B8%B8%E7%94%A8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.html"/>
    <id>http://www.lklogs.com//blog/常用垃圾收集器.html</id>
    <published>2020-05-19T03:36:06.000Z</published>
    <updated>2020-05-20T04:05:54.864Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>本文简单总结一些常用的GC参数，以及最新版本的JDK添加的参数，持续更新中<br><a id="more"></a></p><ul><li>-Xms：堆的最小值</li><li>-Xmx：堆的最大值</li><li>-Xmn：新生代的大小</li><li>-Xss：减少栈内存的容量</li><li>-XX:+PrintCommandLineFlags:默认命令行参数</li><li>-XX:InitialHeapSize：起始堆大小</li><li>-XX:MaxHeapSize：最大堆大小</li><li>-XX:+UseCompressedClassPointers：使用压缩指针</li><li>-XX:+UseCompressedOops：使用普通对象指针压缩</li><li>-XX:BiasedLockingStartupDelay=0:偏向锁延迟为0，默认为4</li><li>-XX:+UnlockDiagnosticVMOptions:解锁检测的参数</li><li>-XX:PrintAssembly:打印汇编代码</li><li>-XX:SurvivorRatio：Eden与Survivor区的比例</li><li>-XX:+HeapDumpOnOutOfMemoryError：可以让虚拟机在出现内存溢出异常的时候Dump出当前内存堆转储快照以便进行事后分析</li><li>-XX:MaxPermSize/-XX:MaxMetaspaceSize：设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存大小</li><li>-XX:MetaspaceSize：指定元空间的初始化空间大小，以字节为单位，达到该值就会触发垃圾回收进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过-XX:MaxMetaspaceSize(如果设置了的话)的情况下，适当提高该值。</li><li>-XX:MinMetaspaceFreeRatio：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率，类似的还有-XX:MaxMetaspaceFreeRatio，用于控制最大的元空间剩余容量的百分比</li><li>-XX:MaxDirectMemorySize：直接内存（Direct Memory）的容量大小</li><li>-XX:PretenureSizeThreshold：晋升老年代对象大小</li><li>-XX:MaxTenuringThreshold：设置晋升老年代的年龄阈值</li><li>-Xnoclassgc：对类型进行回收</li><li>-XX:UseCondCardMark：在jdk7之后，HotSpot虚拟机增加了一个新的参数-XX:+UseCondCardMark，用来决定是否开启卡表更新的条件判断。开启会增加一次额外判断的开销，但能够避免伪共享问题，两者各有性能损耗，是否打开要根据应用实际运行情况来进行测试权衡。</li><li>-XX:ParallelGCThreads：限制垃圾收集的线程数</li><li>-XX:MaxGCPauseMillis：控制最大垃圾收集停顿时间</li><li>-XX:GCTimeRatio：设置吞吐量大小</li><li>-XX:+UseAdaptiveSizePolicy：Parallel Scavenge收集器的开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象大小（-XX:PretenureSizeThreshold）等细节参数，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的调节策略。</li><li>-Xlog[:[selector][:[output][:[decorators][:output-options]]]]</li><li>-XX:+PrintGC/-Xlog:gc:(JDK9)：查看GC基本信息</li><li>-XX:+PrintGCDetails/-Xlog:gc*(JDK9)：查看GC详细信息</li><li>-XX:PrintHeapAtGC/-Xlog:gc+heap=debug(JDK9)：查看GC前后的堆、方法区可用容量变化</li><li>-XX:+PrintGCApplicationConcurrentTime 和 -XX:+PrintGCApplicationStoppedTime/ -Xlog:safepoint(JDK9)：查看GC过程中用户线程并发时间以及停顿时间</li><li>-XX:+PrintAdaptiveSizePolicy/-Xlog:gc+ergo*=trace：查看收集器Ergonomics机制（自动设置堆空间各分代区域大小，收集目标等内容，从Parallel收集器开始支持）自动调节的相关信息。</li><li>-XX:+PrintTenuringDistribution/-Xlog:gc+age=trace：查看熬过收集后剩余对象的年龄分布信息</li><li>-XX:PretenureSizeThreshold：指定大于该设置值的对象直接在老年代分配，这样做的目的表面在Eden区以及两个Survivor区之间来回复制，产生大量的内存复制操作。</li><li>-XX:HandlePromotionFailure：设置值是否允许担保失败（Handle Promotion Failure）；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX:HandlePromotionFailure设置不允许冒险，那这时就要改为一次Full GC</li><li>-XX:-UseSplitVerifier：关闭字节码验证优化</li><li>-XX:+FailOverToOldVerifier：在类型验证失败的时候退回到旧的类型推导方式进行校验。</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单总结一些常用的GC参数，以及最新版本的JDK添加的参数，持续更新中&lt;br&gt;
    
    </summary>
    
      <category term="GC笔记" scheme="http://www.lklogs.com/categories/GC%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="GC" scheme="http://www.lklogs.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>多线程问题总结</title>
    <link href="http://www.lklogs.com//blog/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html"/>
    <id>http://www.lklogs.com//blog/多线程问题总结.html</id>
    <published>2020-01-15T10:32:59.000Z</published>
    <updated>2020-01-15T14:22:14.161Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>多线程相关问题总结，包含答案<br><a id="more"></a></p><ol><li>并发的三要素<br>a)    原子性：原子性是指一个或者多个操作，要么全部执行并且在执行过程中不被其他操作打断，要么全部不执行。<br>b)    可见性：指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他线程可以立即看到修改的结果。<br>c)    有序性：即程序的执行顺序按照代码的先后顺序来执行。  </li><li>实现可见性的方法有哪些？<br>synchronized或者Lock：保证同一个时刻只有一个线程获取锁执行代码，锁释放之前把最新的值刷新到主内存，实现可见性。</li><li>多线程的价值？<br>a)    发挥多核CPU的优势：多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的，采用多线程的方式去同时完成几件事情而不互相干扰<br>b)    防止阻塞：从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行<br>c)    便于建模：这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。  </li><li>创建线程的有哪些方式？<br>a)    继承Thread类创建线程类<br>b)    通过Runnable接口创建线程类<br>c)    通过Callable和Future创建线程<br>d)    通过线程池创建  </li><li>创建线程的三种方式的对比？<br>a)    采用实现Runnable、Callable接口的方式创建多线程。<br>优势是：<br>线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。<br>在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。<br>劣势是：<br>编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。<br>b)    使用继承Thread类的方式创建多线程<br>优势是：<br>编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。<br>劣势是：<br>线程类已经继承了Thread类，所以不能再继承其他父类。<br>c)    Runnable和Callable的区别<br>Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。<br>Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。<br>Call方法可以抛出异常，run方法不可以。<br>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果  </li><li>线程的状态流转图<br>线程的生命周期及五种基本状态  </li><li>Java线程具有五中基本状态<br>a)    新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread()；<br>b)    就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；<br>c)    运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中<br>d)    阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。<br>根据阻塞产生的原因不同，阻塞状态又可以分为三种：</li></ol><ul><li>等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；  </li><li>同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；  </li><li>其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。<br>e)    死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。    </li></ul><ol start="8"><li>什么是线程池？有哪几种创建方式？<br>线程池就是提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务。由于创建和销毁线程都是消耗系统资源的，所以当你想要频繁的创建和销毁线程的时候就可以考虑使用线程池来提升系统的性能。<br>java 提供了一个 java.util.concurrent.Executor接口的实现用于创建线程池。</li><li>四种线程池的创建：<br>a)    newCachedThreadPool创建一个可缓存线程池<br>b)    newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数。<br>c)    newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。<br>d)    newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务。</li><li>线程池的优点？<br>a)    重用存在的线程，减少对象创建销毁的开销。<br>b)    可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。<br>c)    提供定时执行、定期执行、单线程、并发数控制等功能。</li><li>常用的并发工具类有哪些？<br>a)    CountDownLatch<br>b)    CyclicBarrier<br>c)    Semaphore<br>d)    Exchanger</li><li>CyclicBarrier和CountDownLatch的区别<br>a)    CountDownLatch简单的说就是一个线程等待，直到他所等待的其他线程都执行完成并且调用countDown()方法发出通知后，当前线程才可以继续执行。<br>b)    cyclicBarrier是所有线程都进行等待，直到所有线程都准备好进入await()方法之后，所有线程同时开始执行！<br>c)    CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。<br>d)    CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。如果被中断返回true，否则返回false</li><li>synchronized的作用？<br>在Java中，synchronized关键字是用来控制线程同步的，就是在多线程的环境下，控制synchronized代码段不被多个线程同时执行。<br>synchronized既可以加在一段代码上，也可以加在方法上。</li><li>volatile关键字的作用<br>对于可见性，Java提供了volatile关键字来保证可见性。<br>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。<br>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</li><li>什么是CAS<br>CAS是compare and swap的缩写，即我们所说的比较交换。<br>cas是一种基于锁的操作，而且是乐观锁。在java中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加version来获取数据，性能较悲观锁有很大的提高。<br>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。<br>java.util.concurrent.atomic 包下的类大多是使用CAS操作来实现的( AtomicInteger,AtomicBoolean,AtomicLong)。</li><li>CAS的问题<br>a)    CAS容易造成ABA问题<br>一个线程a将数值改成了b，接着又改成了a，此时CAS认为是没有变化，其实是已经变化过了，而这个问题的解决方案可以使用版本号标识，每操作一次version加1。在java5中，已经提供了AtomicStampedReference来解决问题。<br>b)    不能保证代码块的原子性<br>CAS机制所保证的知识一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用synchronized了。<br>c)    CAS造成CPU利用率增加<br>之前说过了CAS里面是一个循环判断的过程，如果线程一直没有获取到状态，cpu资源会一直被占用。</li><li>什么是Future？<br>在并发编程中，我们经常用到非阻塞的模型，在之前的多线程的三种实现中，不管是继承thread类还是实现runnable接口，都无法保证获取到之前的执行结果。通过实现Callback接口，并用Future可以来接收多线程的执行结果。<br>Future表示一个可能还没有完成的异步任务的结果，针对这个结果可以添加Callback以便在任务执行成功或失败后作出相应的操作。</li><li>什么是AQS<br>AQS是AbustactQueuedSynchronizer的简称，它是一个Java提高的底层同步工具类，用一个int类型的变量表示同步状态，并提供了一系列的CAS操作来管理这个同步状态。<br>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。</li><li>AQS支持两种同步方式：<br>a)    独占式<br>b)    共享式<br>这样方便使用者实现不同类型的同步组件，独占式如ReentrantLock，共享式如Semaphore，CountDownLatch，组合式的如ReentrantReadWriteLock。总之，AQS为使用提供了底层支撑，如何组装实现，使用者可以自由发挥。</li><li>ReadWriteLock是什么<br>首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。<br>因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</li><li>FutureTask是什么<br>这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</li><li>synchronized和ReentrantLock的区别<br>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：<br>a)    ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁<br>b)    ReentrantLock可以获取各种锁的信息<br>c)    ReentrantLock可以灵活地实现多路通知<br>另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</li><li>什么是乐观锁和悲观锁<br>a)    乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。<br>b)    悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</li><li>线程B怎么知道线程A修改了变量<br>volatile修饰变量<br>synchronized修饰修改变量的方法<br>wait/notify<br>while轮询</li><li>synchronized、volatile、CAS比较<br>synchronized是悲观锁，属于抢占式，会引起其他线程阻塞。<br>volatile提供多线程共享变量可见性和禁止指令重排序优化。<br>CAS是基于冲突检测的乐观锁（非阻塞）</li><li>sleep方法和wait方法有什么区别?<br>这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</li><li>ThreadLocal是什么？有什么用？<br>ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。<br>简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。</li><li>为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用<br>这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</li><li>多线程同步有哪几种方法？<br>Synchronized关键字，Lock锁实现，分布式锁等。</li><li>线程的调度策略<br>线程调度器选择优先级最高的线程运行，但是，如果发生以下情况，就会终止线程的运行：<br>1）    线程体中调用了yield方法让出了对cpu的占用权利<br>2）    线程体中调用了sleep方法使线程进入睡眠状态<br>3）    线程由于IO操作受到阻塞<br>4）    另外一个更高优先级线程出现<br>5）    在支持时间片的系统中，该线程的时间片用完</li><li>ConcurrentHashMap的并发度是什么<br>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</li><li>Linux环境下如何查找哪个线程使用CPU最长<br>1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过<br>2）top -H -p pid，顺序不能改变</li><li>Java死锁以及如何避免？<br>Java中的死锁是一种编程情况，其中两个或多个线程被永久阻塞，Java死锁情况出现至少两个线程和两个或更多资源。<br>Java发生死锁的根本原因是：在申请锁时发生了交叉闭环申请。  </li><li>死锁的原因<br>a)    是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖的闭环。<br>例如：线程在获得了锁A并且没有释放的情况下去申请锁B，这时，另一个线程已经获得了锁B，在释放锁B之前又要先获得锁A，因此闭环发生，陷入死锁循环。<br>b)    默认的锁申请操作是阻塞的。<br>所以要避免死锁，就要在一遇到多个对象锁交叉的情况，就要仔细审查这几个对象的类中的所有方法，是否存在着导致锁依赖的环路的可能性。总之是尽量避免在一个同步方法中调用其它对象的延时方法和同步方法。</li><li>怎么唤醒一个阻塞的线程<br>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</li><li>不可变对象对多线程有什么帮助<br>前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</li><li>什么是多线程的上下文切换<br>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</li><li>如果你提交任务时，线程池队列已满，这时会发生什么<br>这里区分一下：<br>a)    如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务<br>b)    如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy</li><li>Java中用到的线程调度算法是什么<br>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</li><li>什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？<br>线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</li><li>什么是自旋<br>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</li><li>JavaConcurrency API中的Lock接口(Lockinterface)是什么？对比同步它有什么优势？<br>Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。<br>它的优势有：<br>可以使锁更公平<br>可以使线程在等待锁的时候响应中断<br>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间<br>可以在不同的范围，以不同的顺序获取和释放锁</li><li>单例模式的线程安全性<br>老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：<br>a)    饿汉式单例模式的写法：线程安全<br>b)    懒汉式单例模式的写法：非线程安全<br>c)    双检锁单例模式的写法：线程安全</li><li>Semaphore有什么作用<br>Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</li><li>Executors类是什么？<br>Executors为Executor，ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类提供了一些工具方法。</li><li>Executors可以用于方便的创建线程池<br>线程类的构造方法、静态块是被哪个线程调用的<br>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。<br>如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：<br>1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的<br>2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</li><li>同步方法和同步块，哪个是更好的选择?<br>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。</li><li>Java线程数过多会造成什么异常？<br>a)    线程的生命周期开销非常高<br>b)    消耗过多的CPU资源<br>如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争CPU资源时还将产生其他性能的开销。<br>c)    降低稳定性<br>JVM在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括JVM的启动参数、Thread构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError异常。</li></ol></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程相关问题总结，包含答案&lt;br&gt;
    
    </summary>
    
      <category term="面经" scheme="http://www.lklogs.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="java" scheme="http://www.lklogs.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>线程状态</title>
    <link href="http://www.lklogs.com//blog/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.html"/>
    <id>http://www.lklogs.com//blog/线程状态.html</id>
    <published>2019-09-19T07:19:10.000Z</published>
    <updated>2019-09-20T06:14:22.645Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>主要有三个问题：线程状态，代码实现以及线程资源情况<br><a id="more"></a></p><h2 id="java-线程有哪些状态，分别代表什么含义？"><a href="#java-线程有哪些状态，分别代表什么含义？" class="headerlink" title="java 线程有哪些状态，分别代表什么含义？"></a>java 线程有哪些状态，分别代表什么含义？</h2><p>在源码中找到Thread.state 枚举类型中有线程的状态<br>分别有：</p><ul><li>NEW<br>Thread state for a thread which has not yet started.<br>尚未启动的线程的线程状态.</li><li>RUNNABLE<br>Thread state for a runnable thread.  A thread in the runnable state is executing in the Java virtual machine but it maybe waiting for other resources from the operating system such as processor.<br>可运行线程的线程状态。 处于可运行状态的线程正在Java虚拟机中执行，但它可能正在等待来自操作系统的其他资源，例如处理器。</li><li>BLOCKED<br>Thread state for a waiting thread. A thread in the waiting state is waiting for another thread to perform a particular action.<br>等待线程的线程状态.处于等待状态的线程正在等待另一个线程执行特定操作。</li><li>TIMED_WAITING<br>Thread state for a waiting thread with a specified waiting time. A thread is in the timed waiting state due to calling one of<br>具有指定等待时间的等待线程的线程状态。由于调用其中一个线程，线程处于定时等待状态</li><li>TERMINATED<br>Thread state for a terminated thread. The thread has completed execution.<br>终止线程的线程状态。 线程已完成执行。<h2 id="如何获取当前JVM所有的线程状态？"><a href="#如何获取当前JVM所有的线程状态？" class="headerlink" title="如何获取当前JVM所有的线程状态？"></a>如何获取当前JVM所有的线程状态？</h2><h3 id="命令实现："><a href="#命令实现：" class="headerlink" title="命令实现："></a>命令实现：</h3>jps 查看java线程pid<br>jstack [pid]<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3>使用JMX<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadInfo;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadMXBean;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取JVM所有的线程状态</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllThreadStackQuestion</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) {</span><br><span class="line">        <span class="type">ThreadMXBean</span> threadMXBean = <span class="type">ManagementFactory</span>.getThreadMXBean();</span><br><span class="line">        long[] allThreadIds = threadMXBean.getAllThreadIds();</span><br><span class="line">        <span class="keyword">for</span> (long threadid : allThreadIds) {</span><br><span class="line">            <span class="type">ThreadInfo</span> threadInfo = threadMXBean.getThreadInfo(threadid);</span><br><span class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(threadInfo.<span class="built_in">toString</span>());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="如何获取线程的资源消费情况？"><a href="#如何获取线程的资源消费情况？" class="headerlink" title="如何获取线程的资源消费情况？"></a>如何获取线程的资源消费情况？</h2><p>JMX的拓展实现<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.management.ThreadMXBean;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取线程的消费情况</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllThreadInfoQuestion</span> {</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ThreadMXBean threadMXBean = (ThreadMXBean) ManagementFactory.getThreadMXBean();</span><br><span class="line">        <span class="keyword">long</span>[] allThreadIds = threadMXBean.getAllThreadIds();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> threadid : allThreadIds) {</span><br><span class="line">            <span class="keyword">long</span> threadAllocatedBytes = threadMXBean.getThreadAllocatedBytes(threadid);</span><br><span class="line">            <span class="keyword">long</span> kBytes = threadAllocatedBytes / <span class="number">1024</span>;</span><br><span class="line">            System.out.<span class="built_in">printf</span>(<span class="string">"线程[ID: %d] 分配内存： %s KB \n"</span>, threadid, kBytes);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要有三个问题：线程状态，代码实现以及线程资源情况&lt;br&gt;
    
    </summary>
    
      <category term="面经" scheme="http://www.lklogs.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="java" scheme="http://www.lklogs.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>常见函数相关</title>
    <link href="http://www.lklogs.com//blog/%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3.html"/>
    <id>http://www.lklogs.com//blog/常见函数相关.html</id>
    <published>2019-08-20T02:02:53.000Z</published>
    <updated>2019-08-20T02:44:03.491Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>梳理和总结一下的常见的函数，以及函数的创建与使用<br><a id="more"></a></p><h3 id="一-单行函数"><a href="#一-单行函数" class="headerlink" title="一. 单行函数"></a>一. 单行函数</h3><ul><li>字符函数  <ul><li>length(str) 获取参数值的字节个数;utf8下1个字母占用1个字节，1个汉字占用3个字节</li><li>concat(str,str,…) 拼接字符串</li><li>upper 大写</li><li>lower 小写</li><li>substr/substring 截取字符</li><li>instr 返回子串第一次出现的索引，如果找不到返回0</li><li>trim 默认去除字符串的空格，可以指定去除的字符串，例如trim(‘a’ FROM ‘aaaabbaa’) 以’a’为一个单位去除，给定的字符串为一个单位前后去除</li><li>lpad 用指定的字符实现左填充指定长度</li><li>rpad 用指定的字符实现右填充指定长度</li><li>replace(str, from_str, to_str) 替换</li><li>[m]-[n] diffrence 查询m和n的差距</li><li>group_concat(字段名) 一个字段多个值拼接，常和group by一起使用</li></ul></li><li>数字函数<ul><li>round 四舍五入/round(number,n) 保留n位小数</li><li>ceil 向上取整，返回>=该参数的最小整数</li><li>floor 向下取整，返回<=该参数的最大整数</li><li>truncate 截断</li><li>mod 取余 mod(a,b) : a-a/b*b</li><li>rand 获取随机数，返回0-1之间的小数</li></ul></li><li>日期函数<ul><li>now 返回当前系统日期+时间</li><li>curdate 返回当前系统日期，不包含时间</li><li>curtime 返回当前时间，不包含日期</li><li>year(date) 获取年</li><li>month(date) 获取月</li><li>day(date) 获取日</li><li>hour(date) 获取小时</li><li>minute(date) 获取分钟</li><li>second(date) 获取秒</li><li>monthname(date) 获取英文月</li><li>datediff(date,date) 返回两个日期相差天数</li><li>str_to_date(‘9-13-1999’,’%m-%d-%Y’) 将日期格式的字符转换成指定格式的日期 1999-09-13</li><li>date_format(‘2018/6/6’,’%Y年%m月%d日’) 将日期转换成字符 2018年06月06日   </li></ul></li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/mysql/date.png" alt>   </p><ul><li>其他函数<ul><li>version() 查看当前mysql版本号</li><li>database() 查看当前的数据库</li><li>user() 查看当前的用户</li><li>password(“字符”) 返回该字符的密码形式</li><li>MD5(“字符”) md5加密</li></ul></li><li>流程定义函数  <ul><li>if  </li><li>case  </li></ul></li></ul><h3 id="二-分组函数"><a href="#二-分组函数" class="headerlink" title="二. 分组函数"></a>二. 分组函数</h3><ul><li>sum</li><li>avg</li><li>max</li><li>min</li><li>count<ul><li>MYISAM存储引擎下，count(<em>)的效率高<br>INNODB存储引擎下，count(</em>)和count(1)的效率差不多，比count(字段)要高一些  </li></ul></li></ul><h3 id="三-函数创建和使用"><a href="#三-函数创建和使用" class="headerlink" title="三. 函数创建和使用"></a>三. 函数创建和使用</h3><p>注意：函数肯定有一个返回值  </p><ul><li>创建<br>create function 函数名(参数名 参数类型) returns 返回类型<br>begin<br>  函数体<br>end;  </li><li>调用<br>select 函数名(实参列表)</li><li>查看<br>show create function 函数名;</li><li>删除<br>drop function 函数名;</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;梳理和总结一下的常见的函数，以及函数的创建与使用&lt;br&gt;
    
    </summary>
    
      <category term="mysql笔记" scheme="http://www.lklogs.com/categories/mysql%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://www.lklogs.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Thread基础</title>
    <link href="http://www.lklogs.com//blog/Thread%E5%9F%BA%E7%A1%80.html"/>
    <id>http://www.lklogs.com//blog/Thread基础.html</id>
    <published>2019-06-13T06:21:43.000Z</published>
    <updated>2019-06-13T08:30:32.017Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>现代操作系统调度的最小单元是线程，也叫轻量级进程(Light Weight Process)，在一个进程中可以创建多个线程，这些线程拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量<br><a id="more"></a></p><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Method</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{        <span class="comment">// 获取线程管理MXBean</span>        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();        <span class="comment">// 不需要获取同步的monitor和synchronizer信息，仅获取线程和线程堆栈信息</span>        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);        <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) {            System.out.println(<span class="string">"线程ID "</span> + threadInfo.getThreadId() + <span class="string">" 线程名称 "</span> + threadInfo.getThreadName());        }    }}</code></pre><pre><code class="python">线程ID <span class="number">8</span> 线程名称 JDWP Command Reader //JDWP 命令读取器线程线程ID <span class="number">7</span> 线程名称 JDWP Event Helper Thread //JDWP 事件帮助器线程线程ID <span class="number">6</span> 线程名称 JDWP Transport Listener: dt_socket // JDWP 运行的被调试应用和调试者之间的通信协议线程线程ID <span class="number">5</span> 线程名称 Attach Listener // Attach 监听器线程线程ID <span class="number">4</span> 线程名称 Signal Dispatcher // 分发处理发送给JVM信号的线程线程ID <span class="number">3</span> 线程名称 Finalizer // 调用对象finalize方法的线程线程ID <span class="number">2</span> 线程名称 Reference Handler // 清除Reference的线程线程ID <span class="number">1</span> 线程名称 main // main线程，用户线程入口</code></pre><h1 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h1><p>前景提要：现在操作系统采用时分的形式调度运行的线程(争抢CPU时间片)<br>方法：setPriority(int)<br>首先，我们创建一个简单的线程类似于</p><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Method</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{        Thread thread = <span class="keyword">new</span> Thread(() -> {            System.out.println(<span class="string">"1111111111"</span>);        });        System.out.println(thread.getPriority());        thread.start();    }}</code></pre><p>getPriority()的输出值为5.可以得出线程的默认级别是5。<br>查看下方源码</p><pre><code class="java"><span class="keyword">public</span><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{    <span class="comment">/**</span><span class="comment">     * The minimum priority that a thread can have.</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;    <span class="comment">/**</span><span class="comment">     * The default priority that is assigned to a thread.</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;    <span class="comment">/**</span><span class="comment">     * The maximum priority that a thread can have.</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>{        ThreadGroup g;        checkAccess();        <span class="keyword">if</span> (newPriority > MAX_PRIORITY || newPriority < MIN_PRIORITY) {            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();        }        <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) {            <span class="keyword">if</span> (newPriority > g.getMaxPriority()) {                newPriority = g.getMaxPriority();            }            setPriority0(priority = newPriority);        }    }}</code></pre><p>从源码中我们可以得出，优先级的范围从1~10.<br>总结：  </p><ul><li>优先级高的线程分配时间片的数量要多于优先级低的线程</li><li>针对频繁阻塞(休眠或者I/O操作)的线程需要设置较高优先级，对于偏重计算(需要较多CPU时间或者偏运算)的线程设置较低的优先级，确保处理器不会独占</li><li>不同的JVM和操作系统上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定</li><li>线程优先级不能作为程序正确性的依赖</li></ul><h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p>Java线程的状态<br>NEW : 初始化状态，线程被构建，但是还没有调用start方法<br>RUNNABLE : 运行状态，Java线程将操作系统中的就绪和运行两种状态统称为“运行中”<br>BLOCKED  : 阻塞状态，表示线程阻塞于锁<br>WAITING : 等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断)<br>TIME_WAITING : 超时等待状态，该状态不同于WAITING，它是可以在指定的时间自行返回的<br>TERMINATED : 终止状态，表示当前线程已经执行完毕<br>Java线程状态变迁图<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/Thread/ThreadStatus.png" alt>  </p><h1 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h1><p>Daemon线程是一种支持型线程，因为他主要被用作程序中后台调度以及支持性工作。<br>方法：setDaemon(true)<br>总结：Daemon线程用作完成支持性工作，但是在Java虚拟机退出时，Daemon线程中的finally块并不一定执行<br>注意：在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现代操作系统调度的最小单元是线程，也叫轻量级进程(Light Weight Process)，在一个进程中可以创建多个线程，这些线程拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量&lt;br&gt;
    
    </summary>
    
      <category term="Thread笔记" scheme="http://www.lklogs.com/categories/Thread%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Thread" scheme="http://www.lklogs.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>GC标记-清除算法</title>
    <link href="http://www.lklogs.com//blog/GC%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.html"/>
    <id>http://www.lklogs.com//blog/GC标记-清除算法.html</id>
    <published>2019-05-17T09:22:49.000Z</published>
    <updated>2019-05-19T04:35:12.107Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>本文介绍GC标记-清除算法的过程以及相关需要注意到的细节点<br><a id="more"></a></p><h2 id="标记和清除"><a href="#标记和清除" class="headerlink" title="标记和清除"></a>标记和清除</h2><ul><li>标记(遍历对象并标记)<br>简介：所有活动对象做标记的阶段；  <ul><li>首先要标记通过根直接引用的对象，然后递归地标记通过指针数组能访问到的对象</li><li>避免重复标记，程序在对象头进行置位操作，例如：obj.mark为真，已标记；obj.mark为假，未标记</li><li>在标记阶段，程序会标记所以活动对象，标记花费时间与“活动对象的总数”成正比</li><li>大多数情况下会使用深度优先搜索，缘由：深度优先搜索比广度优先搜索更能压低内存使用量<br><code>了解深度优化搜索与广度优先搜索</code></li></ul></li><li>清除：非活动对象回收阶段；<ul><li>会在堆从头到尾遍历,设置其中对象的标志位(活动对象) 将obj.mark == ture变更为obj.mark = false,便于下次标记，而obj.mark == false(也就是未标记的)存储起来便于清除</li><li>回收对象：把对象作为分块，连接到被称为“空闲链表”的单向链表；以便之后分块，“分配”可以遍历“空闲链表”</li><li>GC重写对象的域，</li><li>花费时间与堆大小成正比<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/GC/TagStatus.jpg" alt>  </li></ul></li></ul><h2 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h2><p>mutator申请分块时情况：  </p><ul><li>找到大小相同的分块直接返回</li><li>找到比申请大的分块，分割，去掉剩余，返回相同大小的分块</li><li>没有找到相同的分块，返回null,分配停止  </li></ul><h3 id="First-fit、Best-fit、Worst-fit-分配策略"><a href="#First-fit、Best-fit、Worst-fit-分配策略" class="headerlink" title="First-fit、Best-fit、Worst-fit 分配策略"></a>First-fit、Best-fit、Worst-fit 分配策略</h3><ul><li>First-fit：发现大小等于mutator申请大小立即返回</li><li>Best-fit：遍历空闲链表，返回大于等于mutator申请大小的最小分块</li><li>Worst-fit：找出空闲链表中最大的分块，分割成mutator申请大小和分割后剩余的大小，目的将分割块最大化(弊端：很容易生产大量小的分块)  </li></ul><h2 id="合并-连接连续分块"><a href="#合并-连接连续分块" class="headerlink" title="合并(连接连续分块)"></a>合并(连接连续分块)</h2><p>缘由：根据分配策略的不同可能会产生大量的小分块<br>场景：合并是在清除阶段进行的</p><blockquote><p>发现分块，判断分块是否连续，连续合并整理成一个分块</p></blockquote><h2 id="GC标记-清除算法的优点"><a href="#GC标记-清除算法的优点" class="headerlink" title="GC标记-清除算法的优点"></a>GC标记-清除算法的优点</h2><ul><li>实现简单(算法简单)</li><li>与保守式GC算法兼容(保守式GC算法中，对象是不能移动的)<ul><li>GC标记-清除算法不会移动对象</li></ul></li></ul><h2 id="GC标记-清除算法的缺点"><a href="#GC标记-清除算法的缺点" class="headerlink" title="GC标记-清除算法的缺点"></a>GC标记-清除算法的缺点</h2><ul><li>碎片化(fragmentation)<ul><li>在使用过程中会逐渐产生被细化的分块，不久后就会导致无数的小分块散步在堆的各处</li><li>会增加mutator的执行负担</li><li>把具有引用关系的对象安排在堆中较远的位置，就会增加访问所需要的时间</li></ul></li><li>分配速度<ul><li>每次都必须遍历空闲链表，找到足够大的分块，最大时间复杂度</li></ul></li><li>写时复制技术(copy-on-write)<blockquote><p>liunx等众多UNIX操作系统的虚拟存储中用到的高速化方法；<br>而写时复制技术实际上是将内存空间共享；因为数据一致性的缘故不能直接重写共享内存；重写时，需要复制自己私有空间的数据，对这个私有空间进行重写，复制后只访问这个私有空间，不访问共享内存；此过程叫做在写入时进行复制<br>不兼容的原因：GC标记-清除算法即使没有重写对象，GC也会设置所有活动对象的标志位，会导致频繁发生不必要的复制，压迫内存空间<br>** 与之技术不兼容，因为GC设置所有活动对象的标志位，会频繁发生本不应该发生的复制，压迫内存空间，处理方式：位图标记(bitmap marking)</p></blockquote><h2 id="多个空闲链表"><a href="#多个空闲链表" class="headerlink" title="多个空闲链表"></a>多个空闲链表</h2>一个空闲链表的情况<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/GC/OneFreeList.png" alt><br>多个空闲链表的情况<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/GC/MoreFreeList.png" alt><br>需要根据分块所需大小分成多个空闲链表；例如1个字的空闲链表、2个字的空闲链表、3个字的空闲链表…..<br>解决方式：设置上限空闲链表，按需找到指定大小分块的空闲链表，可以调高效率，但是也不能过多，否则会对内存空间造成浪费</li></ul><h2 id="BiBOP法-将大小相近的对象整理成固定大小的块进行管理的方法"><a href="#BiBOP法-将大小相近的对象整理成固定大小的块进行管理的方法" class="headerlink" title="BiBOP法(将大小相近的对象整理成固定大小的块进行管理的方法)"></a>BiBOP法(将大小相近的对象整理成固定大小的块进行管理的方法)</h2><p>创造出算法的缘由：为了能在GC标记-清除算法中高速进行分配而想出的方法<br>缺点：如果多个块中分散残留着同样大小的对象，反而会降低堆使用效率<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/GC/BIBOP.png" alt></p><h2 id="位图标记-收集各个对象的标志位并表格化，不在对象的头里置位，在表格中的特定场所置位"><a href="#位图标记-收集各个对象的标志位并表格化，不在对象的头里置位，在表格中的特定场所置位" class="headerlink" title="位图标记(收集各个对象的标志位并表格化，不在对象的头里置位，在表格中的特定场所置位)"></a>位图标记(收集各个对象的标志位并表格化，不在对象的头里置位，在表格中的特定场所置位)</h2><p>位图标记实现<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/GC/BitmapMark.png" alt><br>方法产生的缘由：在单纯的GC标记-清除算法中，用于标记的位是被分配到各个对象的头中的，也就是说算法是把对象和头一并处理的，这与写时复制技术不兼容；对此产生了只收集各个对象的标志位并表格化，不跟对象一起管理。<br>实现方式：散列表，树形结构等</p><h3 id="位图标记的优点"><a href="#位图标记的优点" class="headerlink" title="位图标记的优点"></a>位图标记的优点</h3><ul><li>与写时复制技术兼容<ul><li>以往的标记操作都是直接对对象设置标志位，会产生无谓的复制  </li><li>虽然使用位图标记是不会对对象设置标志位也就不会发生无谓的复制。因为对位图表格进行重写，所以在此处会发生复制，不过因为位图表格非常小，所以被复制也不会有多大的影响  </li></ul></li><li>清除操作更加高效(避免多次遍历，快速有效的消去标志位)</li><li>多个堆需要每一个都准备一个位图表格(通过对象的地址求其对应的标志位的位置，需进行位运算)  </li></ul><h2 id="延迟清除法"><a href="#延迟清除法" class="headerlink" title="延迟清除法"></a>延迟清除法</h2><p>方法产生的由来：消除操作所花费的时间是与堆大小成正比的，也就是，处理的堆越大，GC标记-清除算法所花费的时间就越长，结果会妨碍到mutator的处理。<br>简介：缩减因清除操作而导致的mutator最大暂停时间的方法<br>过程：  </p><ul><li>调用指定的lazy_sweep函数进行清除操作<ul><li>如果用清除操作来分配分块，就会直接返回分块，反之就会执行标记操作，就算没有分块，mutator也就不会进行下一步处理</li></ul></li><li>遍历的开始位置位于上一次清除操作中发现的分块的右边(不是一下遍历整个堆，只在分配执行必要的遍历所以可以压缩因清除操作而导致的mutator的暂停时间)  <ul><li>遍历到堆最后都没有发现分块时，就会返回null  </li></ul></li></ul><h3 id="延迟清除法弊端"><a href="#延迟清除法弊端" class="headerlink" title="延迟清除法弊端"></a>延迟清除法弊端</h3><p>堆里垃圾分配不均的情况<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/GC/AdjacencyObject.png" alt><br>会形成一种邻接的状态，在此情况下，程序在清除垃圾较多的部分时能马上获取分块，能减少mutator的暂停时间。然而一旦开始清除活动对象周围。就怎么也无法获得分块，也就增加了mutator的暂停时间  </p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍GC标记-清除算法的过程以及相关需要注意到的细节点&lt;br&gt;
    
    </summary>
    
      <category term="GC笔记" scheme="http://www.lklogs.com/categories/GC%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="GC" scheme="http://www.lklogs.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>GC需知</title>
    <link href="http://www.lklogs.com//blog/GC%E9%9C%80%E7%9F%A5.html"/>
    <id>http://www.lklogs.com//blog/GC需知.html</id>
    <published>2019-05-17T01:33:31.000Z</published>
    <updated>2019-12-14T10:26:14.967Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>本文笼统的介绍了GC中的需要事先知晓的技术点，建议配合JVM一起看会有更深层次的理解</p><a id="more"></a><h2 id="GC用途"><a href="#GC用途" class="headerlink" title="GC用途"></a>GC用途</h2><ol><li>找到内存空间的垃圾；</li><li>回收垃圾，能再次利用这部分空间；  </li></ol><h2 id="目前GC主要算法"><a href="#目前GC主要算法" class="headerlink" title="目前GC主要算法"></a>目前GC主要算法</h2><ol><li>GC标记-清除算法</li><li>引用计数法</li><li>GC复制算法</li><li>GC标记-压缩算法</li><li>RC Immix算法</li></ol><h2 id="GC对象：通过应用程序利用的数据的集合"><a href="#GC对象：通过应用程序利用的数据的集合" class="headerlink" title="GC对象：通过应用程序利用的数据的集合"></a>GC对象：通过应用程序利用的数据的集合</h2><ul><li>header(头)(事先存有运行GC所需的信息)<ul><li>对象大小</li><li>对象种类</li></ul></li><li>fieId(域)<ul><li>指针(内存空间中某块区域的值)</li><li>非指针(在编程过程中直接使用值本身，例如：数值、字符以及真假值)<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/GC/headAndfieId.jpg" alt><br><a href="zmdialect://mainpage" target="_blank" rel="noopener">app</a><br><a href="https://www.umeng.com/analytics" target="_blank" rel="noopener">umeng</a><h2 id="mutator-改变对象之间的引用关系"><a href="#mutator-改变对象之间的引用关系" class="headerlink" title="mutator(改变对象之间的引用关系)"></a>mutator(改变对象之间的引用关系)</h2></li></ul></li><li>生成对象</li><li>更新指针     </li></ul><h2 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆(heap)"></a>堆(heap)</h2><p>简介：动态存放对象的内存空间<br>使用：mutator 存放对象—>堆分配    </p><h2 id="活动对象-非活动对象"><a href="#活动对象-非活动对象" class="headerlink" title="活动对象/非活动对象"></a>活动对象/非活动对象</h2><p>活动对象：mutator引用的对象<br>非活动对象：不被引用的对象(销毁释放内存)     </p><blockquote><p>!–// 非活动对象不可重新引用  </p></blockquote><h2 id="分配allocation"><a href="#分配allocation" class="headerlink" title="分配allocation"></a>分配allocation</h2><p>简介：内存空间中分配对象<br>用途：mutator需要新对象时,向分配器(allocator)申请一个大小合适的空间<br>对堆的操作：在堆的可用空间中找寻满足要求的空间，返回给mutator </p><ul><li>无法分配时</li></ul><ol><li>销毁至今为止的所有计算结果，输出错误信息</li><li>扩大堆，分配可用空间</li></ol><h2 id="分块-chunk"><a href="#分块-chunk" class="headerlink" title="分块(chunk)"></a>分块(chunk)</h2><p>简介：为利用对象而事先准备出来的空间(初始状态下，堆被一个大的分块所占据)<br>用途：根据mutator的要求分块分割合适大小<br>过程：分块 -> 活动对象 -> 垃圾(非活动对象) -> 分块 -> ……</p><h2 id="根-root"><a href="#根-root" class="headerlink" title="根(root)"></a>根(root)</h2><p>简介：在GC的世界里，根是指向对象指针的‘起点’<br>同类：调用栈(call stack)、寄存器和全局变量空间</p><blockquote><p>! GC一般情况下无法严谨判断寄存器和调用栈中的值是非指针<br>伪代码<br>$obj = Object.new<br>$obj.fieId1 = Object.new </p></blockquote><h2 id="评价标准"><a href="#评价标准" class="headerlink" title="评价标准"></a>评价标准</h2><ul><li>吞吐量</li><li>最大暂停时间</li><li>堆使用效率</li><li>访问的局限性</li></ul><h3 id="吞吐量-throughput"><a href="#吞吐量-throughput" class="headerlink" title="吞吐量(throughput)"></a>吞吐量(throughput)</h3><p>简介：在单位时间内的处理能力<br>条件：mutator开始执行到结束之间GC花费时间<br>GC吞吐量为<code>HEAP_SIZE/GC花费时间</code> </p><blockquote><p>! 不同算法有不同的吞吐量<br>例如:</p><ul><li>GC复制算法 活动对象越少吞吐量越高 -> 只检查活动对象  </li><li>GC标记-清除算法 会检查所有活动对象和非活动对象<br>极端情况下GC标记-清除算法比GC复制算法表现的吞吐量更高的情况<br>!–// 所以有必要把mutator的动作也考虑在内<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/GC/mytatorAndGC.jpg" alt> </li></ul></blockquote><h3 id="最大暂停时间"><a href="#最大暂停时间" class="headerlink" title="最大暂停时间"></a>最大暂停时间</h3><p>简介：因执行GC而暂停执行mutator的最长时间<br>优化：根据执行的应用所重视的指标的不同，来分别采用不同的GC算法  </p><h3 id="堆使用效率"><a href="#堆使用效率" class="headerlink" title="堆使用效率"></a>堆使用效率</h3><p>因素：  </p><ul><li>头的大小<blockquote><p>头中堆放的信息控制在最小限度</p></blockquote></li><li>堆的用法<blockquote><p>可用堆越大，GC运行越快；相反，越想有效利用有限的堆，GC花费的时间越长</p></blockquote></li></ul><h3 id="访问的局限性"><a href="#访问的局限性" class="headerlink" title="访问的局限性"></a>访问的局限性</h3><p>简介：引用关系的对象间的连续访问</p><blockquote><p>考虑到局限性，具有引用关系的对象安排在堆较近的位置，能提高在缓存中读取到想利用的数据的概率，令mutator高速运行<br>！GC复制算法会根据引用关系重排对象<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/GC/storagefabric.jpg" alt></p></blockquote><p>本文持续更新中。。。。。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文笼统的介绍了GC中的需要事先知晓的技术点，建议配合JVM一起看会有更深层次的理解&lt;/p&gt;
    
    </summary>
    
      <category term="GC笔记" scheme="http://www.lklogs.com/categories/GC%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="GC" scheme="http://www.lklogs.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>GC收集器</title>
    <link href="http://www.lklogs.com//blog/GC%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93.html"/>
    <id>http://www.lklogs.com//blog/GC参数总结.html</id>
    <published>2019-05-15T02:16:51.000Z</published>
    <updated>2019-05-15T09:01:30.582Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/GC/GClogo.jpg" alt><br>本文总结于《垃圾回收的算法与实现》,如想购买，请点击<a href="https://item.jd.com/12010270.html" target="_blank" rel="noopener">京东购物地址</a><br><a id="more"></a></p><h2 id="HotSpot虚拟机的垃圾收集器"><a href="#HotSpot虚拟机的垃圾收集器" class="headerlink" title="HotSpot虚拟机的垃圾收集器"></a>HotSpot虚拟机的垃圾收集器</h2><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/GC/HotSpot.png" alt></p><h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><blockquote><ul><li>Stop The World：虚拟机自动发起自动完成，把用户正常工作的线程全部停掉。  </li><li>并行(Parallel):多条垃圾收集线程并行工作，此时用户线程仍然处于等待状态  </li><li>并发(Concurrent):用户线程与垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，用户程序在继续运行，垃圾收集器程序运行在另一个CPU上.  </li><li>吞吐量(Throughput):CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 运行用户代码时间/(运行用户代码时间+垃圾收集时间)  </li><li>GC自适应的调节策略(GC Ergonomics):虚拟机根据当前系统运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。  </li></ul></blockquote><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>简介：单线程收集器(暂停其他所有工作线程，直到收集完毕)<br>用处：Client模式下的默认新生代收集器。<br>优点：简单而高效，对于单CPU环境而言有着最高的单线程收集效率。<br>参数:<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:SurvivorRatio</span><br><span class="line">-XX:PretenureSizeThreshold</span><br><span class="line">-XX:HandlePromotionFailure</span><br></pre></td></tr></tbody></table></figure><p></p><p>Serial/Serial Old收集器的运行过程<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/GC/Serial-SerialOld.jpg" alt></p><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>简介：Serial收集器的多线程版本；调试、收集算法、Stop The World、对象分配规则、回收策略都与Serial收集器完全一样。<br>参数：<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:SurvivorRatio</span><br><span class="line">-XX:PretenureSizeThreshold</span><br><span class="line">-XX:HandlePromotionFailure</span><br><span class="line">-XX:+UseConcMarkSweepGC 选项后的默认新生代收集器</span><br><span class="line">-XX:+UseParNewGC 强制指定</span><br><span class="line">-XX:ParallelGCThreads 限制垃圾回收的线程数</span><br></pre></td></tr></tbody></table></figure><p></p><p>用途：Server模式下的虚拟机中首选的新生代收集器<br>优点：对于GC时系统资源的有效利用还是很有好处的，默认开启的收集线程数与CPU数量相同；<br>ParNew/Serial Old 收集器运行示意图<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/GC/ParNew-SerialOld.jpg" alt></p><h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p>简介：新生代收集器，使用复制算法，并行的多线程收集器<br>优点：达到一个可控制的吞吐量(Throughput)，高效利用CPU时间<br>用途：后台运算而不需要太多交互的任务<br>参数：<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis 控制最大垃圾收集器停顿时间 ><span class="number">0</span> 单位/毫秒</span><br><span class="line">-XX:GCTimeRatio 设置吞吐量大小 <span class="number">0</span><值x<<span class="number">100</span> 最大GC时间：<span class="number">1</span>/(<span class="number">1</span>+x)</span><br><span class="line">-XX:+UseAdaptiveSizePolicy 开关参数 不需要手工指定新生代、Eden与Survivor区的比例(-XX:SurvivorRatio)、晋升老年代对象的年龄(-XX:PretenureSizeThreshold)等细节参数</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p>简介：老年代收集器，单线程收集器，标记-整理算法<br>用途：  </p><ul><li>主要意义在于Client模式下的虚拟机使用；</li><li>在Server模式下<ul><li>JDK1.5以及之前与Parallel Scavenge收集器搭配使用(与Parallel Old收集器架构中的PS MarkSweep使用)</li><li>作为CMS收集器的后备预案，发生Concurren Mode Failure时使用  </li></ul></li></ul><p>Serial/Serial Old 收集器运行示意图<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/GC/Serial-SerialOld.jpg" alt>  </p><h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>简介：是Parallel Scavenge收集器的老年代版本，多线程，标记-整理算法，JDK1.6开始提供<br>Parallel Scavcnge/Parallel Old 收集器运行示意图<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/GC/ParallelScavengc-ParallelOld.jpg" alt></p><h2 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h2><p>简介：获取最短回收停顿时间为目标的收集器。标记-清除算法<br>过程：</p><ul><li>初始标记(CMS initial mark)<ul><li>需要Stop The World</li><li>标记GC Roots能直接关联的对象</li><li>速度很快</li></ul></li><li>并发标记(CMS concurrent mark)<ul><li>进行GC Roots Tracing的过程</li><li>与用户线程一起并发执行的</li></ul></li><li>重新标记(CMS remark)<ul><li>修正并发标记期间因用户程序继续运行而导致标记变动的部分对象的标记记录</li><li>速度：初始标记>重新标记>并发标记</li></ul></li><li>并发清除(CMS concurrent sweep)<ul><li>与用户线程一起并发执行的   </li></ul></li></ul><p>优点：并发收集、低停顿<br>缺点：  </p><ul><li>CMS收集器对CPU资源非常敏感</li><li>默认启动的回收线程数是(CPU数量+3)/4；</li><li>优势：虚拟机提供了“增量式并发收集器”(Incremental COncurrent Mark Sweep /i-CMS):减少GC线程的独占资源时间；</li><li>弊端：垃圾收集过程更长，对用户程序的影响显得少一些；</li><li>实践证明：增量时的CMS收集器效果一般，所以deprecated；</li><li>CMS收集器无法处理浮动垃圾(Floating Garbage),可能出现Concurrent Mode Failure 失败而导致另一次的Full GC 的产生<ul><li>浮动垃圾：由于并发清除节点用户线程还在运行，垃圾出现在标记过程之后，只好留待下一次GC时再清理掉</li><li>JDK1.5 CMS收集器当老年代使用了68%的空间激活，或者调高-XX:CMSInitiatingOccupancyFraction来触发，降低内存回收次数保证性能；在JDK1.6 CMS启动阈值提升至92%，预留内存无法满足程序需要，就会出现Concurrent Mode Failure失败，启动预备方案：临时启用Serial Old重新进行老年代的垃圾收集:-XX:CMSInitiatingOccupancyFraction不可设置太高<br>标记-清除算法</li><li>大量内存碎片产生，不得不提前触发一次Full GC，参数：-XX:+UseCMSCompactAtFullConllection开关参数(默认开启)用途顶不住要进行FullGC 时开启内存碎片的合并整理过程(默认值为0，表示每次进入Full GC时都进行碎片整理)  </li></ul></li></ul><p>Concurrent Mark Sweep 收集器运行示意图<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/GC/ConcurrentMarkSweep.jpg" alt></p><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>简介：是一款面向服务端应用的垃圾收集器，标记-整理。<br>优点:</p><ul><li>并行与并发：使用多个CPU(CPU或者CPU核心)缩短Stop The Wrold停顿时间，并发的方式让java程序继续执行。</li><li>分代收集：采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</li><li>空间整合：标记-整理实现，从局部(两个Region之间)看是基于”复制”算法实现的。两种算法不会产生内存空间碎片，避免过多的触发GC.化整为零，同时扫描新生代和老年代Minor GC的效率会下降，所以使用Remembered Set避免全堆扫描。one Region <-> Remembered Set；Reference类型数据进行写操作，会产生一个Write Barrier暂时中断操作，检查Reference引用对象是否处于不同的Region之中(分代例子：老年代是否引用新生代的对象) -> yes:通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。内存回收时，GC根节点的枚举范围加入Remembered Set保证不对全堆扫描也不会有遗漏。  <!-----></li><li>可预测的停顿：低停顿，可以指定M ms时间片段内，消耗不得超过N ms,实时java(RTSJ)的垃圾收集器特征。GC1跟踪各个Region里面的垃圾堆积的价值大小(回收获得的空间大小与回收时间的经验值)，维护一个优先列表，优先回收价值最大的Region(Garbage-First)<br>说明：GC1收集器中没有新生代老年代一说，将整个java堆分为多个大小相同的独立区域(Region)，虽然保留新生代老年代的概念，但新生代和老年代不再是物理隔离，都是一部分Region(不需要连续)的集合。<br>步骤(不计算维护Remembered Set操作)<ul><li>初始标记(Initial Marking)<ul><li>修改TAMS(Next Top at Mark Start)值，下一阶段用户线程并发运行时，正确可用的Region中创建新对象，需要停顿线程，耗时短。</li></ul></li><li>并发标记(Concurrent Marking)<ul><li>GC Root开始对堆中对象进行可达性分析，找出存活对象，耗时较长，可与用户线程并发运行</li></ul></li><li>最终标记(Final Marking)<ul><li>修正并发标记期间变动的标记记录，这段时间对象变化记录在Remembered Set logs中。</li><li>Remembered Set logs合并在Remembered Set中，需要停顿线程，可并发执行。</li></ul></li><li>筛选回收(Live Data Counting and Evacuation)<ul><li>对各个Region的回收价值和成本排序，制定回收计划。</li><li>可与用户程序并发执行，时间可控。</li></ul></li></ul></li></ul><p>G1收集器运行示意图<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/GC/G1.jpg" alt></p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==&quot; data-original=&quot;https://likworld.gitee.io/openimage/GC/GClogo.jpg&quot; alt&gt;&lt;br&gt;本文总结于《垃圾回收的算法与实现》,如想购买，请点击&lt;a href=&quot;https://item.jd.com/12010270.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;京东购物地址&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="GC笔记" scheme="http://www.lklogs.com/categories/GC%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="GC" scheme="http://www.lklogs.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>git命令总结</title>
    <link href="http://www.lklogs.com//blog/git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93.html"/>
    <id>http://www.lklogs.com//blog/git命令总结.html</id>
    <published>2019-05-13T02:57:25.000Z</published>
    <updated>2019-05-15T09:00:39.958Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://likworld.gitee.io/openimage/Git/Git.jpg" alt>本文只作为个人笔记以及参照，如想了解更多详细的讲解，请点击<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">git-scm.com</a><br><a id="more"></a><br>git config --list 查看所有git当时能找到的配置<br>git init 初始化<br>git add 添加需要上传的文件<br>git commit 提交<br>git commit -m “” 提交和提交信息<br>git commit -a 自动把所有已经跟踪过的文件暂存起来一并提交，跳过git add<br>git commit --amend 尝试重新提交<br>git clone [url] 克隆<br>git status 检查当前文件状态<br>git status -s 简要的文件状态信息<br>git status --short 简要的文件状态信息<br>cat [file] 查看文件内容<br>git diff 查看尚未暂存的文件更新了哪些内容<br>git diff --cached 查看已暂存的将要添加到下次提交里的内容<br>git diff --staged 效果与git diff –cached相同，但是在Git1.6.1及更高版本支持<br>git mv [original_name] [new_name] 修改文件名称<br>git log 回顾提交历史<br>git log -p -数字 显示最近几次修改的详细信息，便于代码审查<br>git log --stat 列出修改的文件数，以及行的移出和添加<br>git log --pretty= 不同于默认方式显示，参数有：online、short、full、fuller<br>git checkout –file.name 撤销对文件的修改<br>git remote 查看已经配置的远程仓库服务器<br>git remote -v 显示远程仓库的名称和地址<br>git remote add <shortname> <url> 添加一个新的远程Git仓库<br>git remote show [remote-name] 查看远程仓库的更多信息<br>git remote rename [original_name] [new_name] 修改一个远程仓库的简写名<br>git remote rm [name] 移除一个远程仓库<br>git fetch [remote-name] 访问远程仓库，从中拉取你还没有的数据<br>git fetch 更新你的远程仓库引用<br>git push [remote-name] [branch-name] 推送到远程仓库<br>git push origin [tagname] 显示地推送标签到共享服务器上<br>git tag 列出已有的标签<br>git tag -a [tag] -m [tag_message] 附注标签<br>git tag [tag] 轻量标签<br>git tag -a [tag] [提交历史id] 后期打标签<br>git tag -d [tag] 删除标签<br>git show [tag] 查看标签信息和对应的提交信息<br>git config --global alias.co checkout 设置检出的快捷键别名<br>git config --global alias.br branch 设置分支快捷键别名<br>git config --global alias.ci commit 设置提交快捷键别名<br>git config --global alias.st status 设置查看状态快捷键别名<br>git branch [tagName] 创建分支<br>git branch -d [tagName] 删除分支<br>git branch -v 查看每一个分支最后一次提交<br>git branch --merged 查看哪些分支已经合并到当前分支<br>git branch --no-merged 查看所有包含未合并工作的分支<br>git mergetool 打开一个可视化工具，调整冲突<br>git rebase [remote-name] 某一个分支的修改转移到另一个分支上<br>git rebase --onto [remote-name] [file1] [file2] 从一个特性分支里再分出一个特性分支的提交历史(选中在file2分支里但不在file1分支里的修改，将他们放在remote-name分支上重放)<br>git merge [file] 截取特性分支上的另一个特性分支，然后编辑到其他分支。与git checkout 配合使用</url></shortname></p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==&quot; data-original=&quot;https://likworld.gitee.io/openimage/Git/Git.jpg&quot; alt&gt;本文只作为个人笔记以及参照，如想了解更多详细的讲解，请点击&lt;a href=&quot;https://git-scm.com/book/zh/v2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git-scm.com&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Git笔记" scheme="http://www.lklogs.com/categories/Git%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="http://www.lklogs.com/tags/Git/"/>
    
  </entry>
  
</feed>
